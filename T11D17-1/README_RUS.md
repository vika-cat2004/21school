# T11D17

![This day will help you get acquainted with structures and unions in C.](misc/rus/images/day11_door.png)


## Contents

1. [Chapter I](#chapter-i) \
 1.1. [Level 3. Room 3.](#level-3-room-3)
2. [Chapter II](#chapter-ii) \
 2.1. [List 1. MCO.](#list-1-mco) \
 2.2. [List 2. Instructions.](#list-2-instructions)
3. [Chapter III](#chapter-iii) \
 3.1. [Quest 1. The Doors.](#quest-1-the-doors) \
 3.3. [Quest 2. Linked List.](#quest-2-linked-list) \
 3.4. [Quest 3. Stack for key.](#quest-3-stack-for-key) 
4. [Chapter IV](#chapter-iv)


# Chapter I

## Level 3. Room 3.

***LOADING Level 3… \
LOADING Room 3…***

\> *Осмотреться*

Очередная комната со столом, компьютером, лампой и без книг. Вот только в этот раз там, где должна быть одна дверь, их стало пятнадцать штук. На каждой из них висит странный электронный замок с клавиатурой. Очень подозрительно. Но хотя бы лампа есть - с ней всегда уютнее.

\> *Дернуть первую дверь*

Закрыто.

\> *Дернуть вторую дверь*

Заперто.

\> *Дернуть третью дверь*

Не поддается.

\> *Дернуть четвертую дверь*

Не-а.

\> *Для i = 5, пока i <= 15 -> Дернуть i-ую дверь и увеличить i*

Напрасно потраченное процессорное время...

\> *Осмотреться снова*

Вы замечаете, что рядом с кучей листов на столе лежит оставленная кем-то газетная вырезка. Был ли это ИИ каким-то образом или кто-то до Вас? Хотя странно было бы предположить, будто ИИ читает газеты и, тем более, делает газетные вырезки.

\> *Пробежаться глазами по вырезке*

***LOADING...***


# Chapter II

## List 1. MCO.

Листок пожелтевший и явно повидавший виды. К тому же вырезанный крайне неаккуратно. 

>Mars Climate Orbiter был запущен 11 декабря 1998 года на РН Дельта-2. Аппарат прибыл к Марсу через 9 месяцев. Mars Climate Orbiter 23 сентября 1999 года должен был выдать тормозной импульс и перейти на высокоэллиптическую орбиту с периодом 14 часов, а затем в течение двух месяцев с помощью ряда аэродинамических маневров в верхней атмосфере Марса довести орбиту до круговой. В расчетное время на высоте 193 км аппарат включил двигатели на торможение. Через 5 минут MCO запланировано ушел за Марс и больше никаких сигналов с него не поступало. Из анализа данных было предположено, что аппарат прошел над поверхностью Марса на высоте 57 км вместо расчетных 110 км и распался в атмосфере. Столь большое отклонение было вызвано ошибкой в программном обеспечении миссии: команды по тяге двигателя в программном обеспечении Mars Climate Orbiter использовали единицу измерения силы ньютон, в то время как программное обеспечение на Земле, которое создавало эти команды, использовало британскую единицу измерения (фунт-сила)...

\> *Взять первый лист из стопки под газетной вырезкой*

***LOADING...***


## List 2. Instructions.

Лист похож на вырванную страницу из какой-то книги по программированию... Вероятно, стоит внимательно прочесть.

>Структура - определенный пользователем тип, позволяющий совместно хранить и перемещать несколько значений разного типа. Определение структуры происходит следующим образом:

    struct [имя структуры] {
    определение элемента;
    определение элемента;
    …
    определение элемента;
    } [одна или несколько переменных];

>Использование структур позволяет объединять совместно используемые данные, а также оставляет возможность для дальнейшей модификации передаваемых данных без изменений заголовков функций.
>
>Объем памяти, занимаемый структурой, равен сумме занимаемой памяти всех её элементов. В связи с этим структуры в языке С являются абстракциями с нулевой стоимостью. Элементы структуры располагаются в памяти в том порядке, в котором определены.

\> *Взять следующий лист*

>Объединение - тип данных, позволяющий переиспользовать память для хранения значений различного типа. Определение объединения происходит следующим образом:

    union [имя объединения] {
    определение элемента;
    определение элемента;
    …
    определение элемента;
    } [одна или несколько переменных];

>Занимаемая объединением память определена как память, необходимая для хранения наибольшего элемента объединения.
>.....................

Далее текст нечитаем

>Одним из применений объединений и структур являются, т.н., объединения с меткой. Это структуры, позволяющие хранить в себе один из нескольких допустимых типов данных, и содержащие в себе метку - целое число, по которому можно определить, какой конкретно тип данных находится в объединении в данный момент.

\> *Взять следующий лист*

>Односвязный список - структура данных, состоящая из последовательно связанных узлов, содержащих однотипные данные. Каждый элемент списка имеет указатель на следующий элемент, последний хранит там пустой указатель (0/NULL в C). Списки имеют переменную длину, позволяют легко выполнять объединение множества списков, однако занимают больше памяти и требуют больше элементарных операций на их обход, чем массивы.

***LOADING...***


# Chapter III

## Quest 1. The Doors. 

\> *Внимательно оглядеть комнату в поисках дополнительных подсказок*

Пусто.

\> *Внимательно оглядеть стол в поисках дополнительных подсказок*

Вы замечаете небольшую оранжевую бумажку под клавиатурой. Такие бумажки часто используют как стикеры для напоминаний. 

\> *Взять и прочесть*

Вы уверены? Это может быть личным...

![day11_sticker](misc/rus/images/day11_sticker.png)

\> *Да. Раньше это никого не смущало. Да и выбора у меня немного.*

>src/dmanager_module.c - модуль управления дверьми. \
>Не трогать функцию инициализации дверей, рушится логика ядра комнаты. \
>Все двери не открывать, от этого крашится протокол передачи. \
>Для управления выделить функцию сортировки дверей по возрастанию и закрытия "открытых" дверей. 
> 
>Структура дверей: целочисленный id и числовой статус (0 - закрыто, 1 - открыто).

Выглядит как напоминалка, оставленная кем-то задолго до Вас. Стоит обратить свое внимание на этот модуль управления дверьми, это может помочь.

***== Получен Quest 1. Создать структуру дверей в src/door_struct.h. Сама структура состоит из целочисленного 
id двери и целочисленного status'а (0 - закрыто, 1 - открыто). Исправить программу src/dmanager_module.c так, 
чтобы она отсортировала проинициализированный массив дверей по возрастанию id дверей любым алгоритмом и вывела его в 
формате: "id двери, статус двери". Помимо этого для всех дверей проставить статус "закрыта". Изменять 
функцию инициализации дверей нельзя. Придерживаться структурного подхода. Программа должна собираться при 
помощи Makefile. Имя стадии - door_struct. Исполняемый файл должен располагаться в корне репозитория в папке 
build и иметь имя Quest_1. Решение будет проверяться на утечки памяти и на стилевую норму, инструкции 
как обычно - в `materials` ==***

0, 0<br/>
1, 0<br/>
2, 0<br/>
3, 0<br/>
4, 0<br/>
5, 0<br/>
6, 0<br/>
7, 0<br/>
8, 0<br/>
9, 0<br/>
10, 0<br/>
11, 0<br/>
12, 0<br/>
13, 0<br/>
14, 0<br/>

***LOADING...***


## Quest 2. Linked List.

Итак, двери вроде бы инициализируются. Но как выйти? Для какой двери необходимо прописать статус открыт? Если сделать это для всех дверей, то судя по запискам, это может повлечь за собой какую-то катастрофу.

\> *Перевернуть бумажку*

А вот и продолжение.

>Нужная дверь изменяется каждый день. \
>Номер текущей двери вычисляется через полиномиальную функцию внутренними модулями комнаты. Исходники реализации модуля недоступны. \
>Путём реверс инжиниринга было выявлено, что этот модуль не умеет работать с массивами. В своей работе модуль использовал динамически подключаемую библиотеку с реализацией односвязного списка. Эта библиотека является критически важной для работы модуля, однако бинарный файл с библиотекой был повреждён.

В одном из листов что-то говорилось про односвязный список. Стоит узнать побольше про этот список и заодно разобраться с выделением памяти под него.

***== Получен Quest 2. Разработать программу src/list.c, в которой содержатся реализации функций по работе 
с односвязным списком дверей (`struct node* init(struct door* door)` - инициализация структуры односвязного списка на базе переданной `struct door`, `struct node* add_door(struct node* elem, struct door* door)` - вставка нового элемента `struct door` в односвязный список после переданного узла `elem`, `struct node* find_door(int door_id, struct node* root)` - поиск двери в списке по её id, `struct node* remove_door(struct node* elem, struct node* root)` - удаление элемента списка, `void destroy(struct node* root)` - освобождение памяти, занимаемой структурой списка). Объявления этих функций и структуру односвязного списка вынести в файл src/list.h. Написать модульные тесты для проверки работы функций add_door 
и remove_door односвязного списка в src/list_test.c. Функции методов должны возвращать SUCCESS в случае успешного прохождения 
теста и FAIL - в случае ошибки. Тесты должны собираться при помощи Makefile. Имя стадии - list_test. 
Исполняемый файл должен располагаться в корне репозитория в папке build и иметь имя Quest_2 
Обратите внимание: этот квест будет тестироваться утилитой `cppcheck`==***

***LOADING...***


## Quest 3. Stack for key. 

Окей, необходимая библиотека для работы модуля поиска номера текущей двери написана. Вы видите на экране стремительно заполняющуюся шкалу активности вычислений алгоритма. Спустя пару секунд на экране появляется номер нужной вам двери. С облегчением и чувством удовлетворения от решённой задачи Вы направляетесь к двери.

\> *Дернуть ручку*

Заперто... \
Однако Вы замечаете, что на двери открылся небольшой экранчик. На экране большими буквами горит надпись:

> NO DYNAMIC INT STACK AND/OR STACK OPERATIONS

Вы возвращаетесь к компьютеру и размышляете, что бы это могло значить. Как жаль, что нигде больше нет вспомогательных бумажек... \
Покопавшись в своей памяти, Вы вспоминаете, что стек - это вроде как одна из разновидностей динамических структур данных, которая часто реализуется в виде списка. Видимо, для открытия двери еще требуется написать динамический стек, который в себе содержит целые числа. Для стека необходимо реализовать его стандартный интерфейс: операции заталкивания данных в стек (push) и выталкивания из него (pop). И не забыть сохранить все реализации в src/stack.c, а объявления функций и структуры в src/stack.h. Также стоит написать модульные тесты в src/stack_test.c, чтобы проверить работоспособность стека и его функций. Иначе кто знает, что может случиться, если стек будет неправильно работать..

***== Получен Quest 3. Разработать программу src/stack.c, в которой содержатся реализации функций по работе 
с динамическим стеком (init, push, pop, destroy). Объявления функций и структуры динамического стека, 
хранящего целые числа, вынести в src/stack.h. Написать модульные тесты для проверки работы функций push 
и pop стека в src/stack_test.c. Функции методов должны возвращать SUCCESS в случае успешного прохождения 
теста и FAIL - в случае ошибки. Тесты должны собираться при помощи Makefile. Имя стадии - stack_test. 
Исполняемый файл должен располагаться в корне репозитория в папке build и иметь имя Quest_3. 
Обратите внимание: этот квест будет тестироваться утилитой `cppcheck` ==***

> 
> ***Внимание! Это задание не предусматривает автотестирование***
> 

***LOADING...***


# Chapter IV

\> *Запушить последнюю задачу в репозиторий*

Вроде бы все сделано.

\> *Подойти к нужной двери*

На небольшом экранчике пусто. Видимо Ваш стек подошел для работы двери.

\> *Дернуть ручку*

Дверь поддается и Вы делаете шаг в следующую комнату.

***LOADING...***

